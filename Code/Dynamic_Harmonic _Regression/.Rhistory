NVR.estimate <- optim(NVR.LSS.estimate, E.log)$par
NVR.estimate
######################### STEP 3 #####################
#### Function to evaluate the logarithmic error.
E <- function(NVR, freq, empirical.spectrum, omega.j, structures, sigma2) {
# Number of frequencies
T <- length(freq)
# Number of harmonic components
R <- length(omega.j) - 1
# Matrix T * (R + 1) with components X[i, j] <- S(omega_i, omega_j)
X <- matrix(NA, nrow = T, ncol = (R + 1))
for(r in 1:(R + 1)) {
X[, r] <- S(freq, omega.j[r], type = structures[r])
}
fitted <- sigma2 * ((X %*% NVR) + (1/(2*pi)))
# Evaluating E(sigma)_L;
error <- sum((log(empirical.spectrum) -
log(fitted))^2)
return(error)
}
NVR.nonlinear.estimate <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP, sigma2 = sigma2)
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP, sigma2 = sigma2)
NVR.nonlinear.estimate <- optimising.NVR$par
final.sigma2 <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
final.sigma.est <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "blue", lty = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green", lty = 2)
sigma.est <- c(sigma2, sigma2 * NVR.LSS.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
NVR.LSS.estimate <- NVR.LinearLS(empirical.spectrum = spec,
sigma2 = sigma2,
frequency = freq,
omega.j = omega.j.AP,
structures = structures.AP)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
# Estimating NVR with Step2 (LLS)
NVR.LSS.estimate <- NVR.LinearLS(empirical.spectrum = spec,
sigma2 = sigma2,
frequency = freq,
omega.j = omega.j.AP,
structures = structures.AP)
# Sigma estimate
sigma.est <- c(sigma2, sigma2 * NVR.LSS.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "blue", lty = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green", lty = 2)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
?optim
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
log(1e-10)
log(1e-16)
log(1e-17)
log(0)
library(BB)
install.packages("BB")
library(BB)
?BB
?spg
optimising.NVR$par
NVR.nonlinear.estimate
# Optimising logarithmic error: (THERE ARE WARNINGS)
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
optimising.NVR$par
spg(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2)
NVR.estimate
spg(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2)$par
ciao <- spg(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2)$par
ciao
final.sigma.est <- c(sigma2, sigma2 * ciao)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma,
# by using log loss function
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
final.sigma.est <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma,
# by using log loss function
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
?optim
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
# Final NVR estimate
NVR.nonlinear.estimate <- optimising.NVR$par
# Final sigma^2 estimate
final.sigma.est <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma,
# by using log loss function
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
fitted - data.AP
plot(fitted - data.AP, pch = 19)
variance(data.AP - fitted)
plot(fitted - data.AP, pch = 19, type = "p")
variance(data.AP - fitted)
var(data.AP - fitted)
plot(fitted - data.AP, pch = 19, type = "p")
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
plot(fitted - data.AP, pch = 19, type = "p")
plot(fitted - data.AP, pch = 19, type = "l")
performance.ar.p(data.AP, p = 55, plot = TRUE, legend = FALSE)
performance.ar.p(data.AP, p = 60, plot = TRUE, legend = FALSE)
performance.ar.p(data.AP, p = 20, plot = TRUE, legend = FALSE)
AP.AR14 <- estimate.AR(data = data.AP, p = 15, n.freq = length(data.AP))
freq <- AP.AR14$frequency
spec <- AP.AR14$spectrum
sigma2 <- AP.AR14$sigma2
# Estimating NVR with Step2 (LLS)
NVR.LSS.estimate <- NVR.LinearLS(empirical.spectrum = spec,
sigma2 = sigma2,
frequency = freq,
omega.j = omega.j.AP,
structures = structures.AP)
# Sigma estimate
sigma.est <- c(sigma2, sigma2 * NVR.LSS.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
###### Testing Step 3
# Optimising logarithmic error: (THERE ARE WARNINGS)
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
# Final NVR estimate
NVR.nonlinear.estimate <- optimising.NVR$par
# Final sigma^2 estimate
final.sigma.est <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma,
# by using log loss function
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
T
var(data.AP[2:T] - fitted[2:T])
var(data.AP[10:T] - fitted[10:T])
sd(data.AP[10:T] - fitted[10:T])
sd(data.AP[2:T] - fitted[2:T])
data.AP
T
sigma2
NVR.nonlinear.estimate
######  Testing Kalman Filter #####
source("Spectrums.R")
source("Steps_DHR_Estimation_Algorithm.R")
source("Testing_Steps.R")
source("Kalman_Filter.R")
# Elements defined in "Testing_Steps.R"
data.AP
T
sigma2
NVR.nonlinear.estimate
####### Preparing system, and observational matrixes #####
R <- 1 + 5 # Trend + Harmonic TVP's
n <- 2*R
omega.j <- c(0, 1/12, 1/6, 1/4, 1/3, 1/(2.4))
# Matrix H
H <- get.H(omega.j, T)
# Matrix F
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
F <- bdiag(c(list(F.IRW), replicate((R - 1), F.RW, simplify = FALSE)))
# Matrix G
G.IRW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G <- bdiag(c(list(G.IRW), replicate((R - 1), G.RW, simplify = FALSE)))
# Matrix Q
Q <- diag(rep(sigma2 * NVR.nonlinear.estimate, 1, each = 2))
#### Filtering:
filtered.process <- Kalman.Filter(y = data.AP, F = F, H = H, G = G,
Q = Q, sigma2 = sigma2)
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
# Fitted values
fitted <- fitted.DHR(H, states)
# Plotting true and fitted value (after Filtering)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
setwd("C:/Users/Beniamino/Desktop/Mini_Project_1/Code/Dynamic_Harmonic _Regression")
source("Spectrums.R")
source("Steps_DHR_Estimation_Algorithm.R")
source("Testing_Steps.R")
source("Kalman_Filter.R")
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
F.RW
# Matrix F
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
F <- bdiag(c(list(F.IRW), replicate((R - 1), F.RW, simplify = FALSE)))
F
G.IRW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.IRW
G.RW
# Matrix G
G.IRW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
G <- bdiag(c(list(G.IRW), replicate((R - 1), G.RW, simplify = FALSE)))
Q <- diag(rep(sigma2 * NVR.nonlinear.estimate, 1, each = 2))
#### Filtering:
filtered.process <- Kalman.Filter(y = data.AP, F = F, H = H, G = G,
Q = Q, sigma2 = sigma2)
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
# Fitted values
fitted <- fitted.DHR(H, states)
# Plotting true and fitted value (after Filtering)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted + rnorm(t, 0, sqrt(sigma2)), type = "o", col = "red", pch = 20)
sigma2
plot(1:t, data.AP, type = "o")
lines(1:t, fitted + rnorm(t, 0, sqrt(sigma2)), type = "o", col = "red", pch = 20)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted + rnorm(t, 0, sqrt(sigma2)), type = "o", col = "red", pch = 20)
Backward.Smoothing <- function(filtered.process) {
if(!(class(filtered.process) == "Kalman.Filter")) {
stop("object \'filtered.process\' has to be of class \'Kalman.Filter\'")
}
# Required elements for backward smoothing, given by Kalman.Filter
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
prediction.P <- filtered.process$prediction.P
y <- filtered.process$y
F <- as.matrix(filtered.process$F)
H <- filtered.process$H
G <- filtered.process$G
Q.r <- (filtered.process$Q)/(filtered.process$sigma2)
T <- length(y)
n <- dim(Q.r)[1]
# New elements for backward smoothing
L <- list()
smoothed.states <- list()
smoothed.covariance.states <- list()
# Initial Step
smoothed.states[[T]] <- states[[T]]
L[[T]] <- as.matrix(rep(0, n), ncol = 1)
smoothed.covariance.states[[T]] <- covariance.states[[T]]
# F could be singular, in that case we use the generalised inverse
if(is.singular.matrix(test.F)) {
F.inv <- ginv(F, tol = sqrt(.Machine$double.eps))
}
else {
F.inv <- solve(F)
}
### Backward Pass Smoothing Equations:
for(t in (T-1):1) {
# Lagrange Multiplier
L[[t]] <- t((diag(n) - covariance.states[[t + 1]] %*%
t(H[[t + 1]]) %*%  H[[t + 1]])) %*%
( t(F) %*% L[[t + 1]] - t(H[[t + 1]]) %*%
(y[t + 1] - H[[t + 1]] %*% states[[t + 1]]))
# Smoothed States
smoothed.states[[t]] <- F.inv %*% (smoothed.states[[t + 1]] +
G %*% Q.r %*% t(G) %*% L[[t]])
# Smoothed Covariance States
A <- solve(prediction.P[[t + 1]],
smoothed.covariance.states[[t + 1]] - prediction.P[[t + 1]])
smoothed.covariance.states[[t]] <- covariance.states[[t]] +
covariance.states[[t]] %*% t(F) %*% A %*%
solve(prediction.P[[t + 1]], F %*% covariance.states[[t]])
}
return(list(smoothed.states = smoothed.states,
smoothed.covariance.states = smoothed.covariance.states))
}
source("Spectrums.R")
source("Steps_DHR_Estimation_Algorithm.R")
# Getting data
data.AP <- AirPassengers
T <- length(data.AP)
# Harmonics
omega.j <- c(0, 1/12, 1/6, 1/4, 1/3, 1/(2.4))
omega.j.AP <- c(0, 1/12, 1/6, 1/4, 1/3, 1/(2.4))
# IRW Trend, RW harmonic components
structures.AP <- c("IRW", rep("RW", 5))
# Which p for the AR(p)?
performance.ar.p(data.AP, p = 20, plot = TRUE, legend = FALSE)
# Getting spectrum and residuals variance from AR(P) fitted to AirPassengers
AP.AR14 <- estimate.AR(data = data.AP, p = 14, n.freq = length(data.AP))
freq <- AP.AR14$frequency
spec <- AP.AR14$spectrum
sigma2 <- AP.AR14$sigma2
# Estimating NVR with Step2 (LLS)
NVR.LSS.estimate <- NVR.LinearLS(empirical.spectrum = spec,
sigma2 = sigma2,
frequency = freq,
omega.j = omega.j.AP,
structures = structures.AP)
# Sigma estimate
sigma.est <- c(sigma2, sigma2 * NVR.LSS.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma (LLS)
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  sigma.est, omega.j.AP)),
lwd = 2, col = "green")
###### Testing Step 3
# Optimising logarithmic error: (THERE ARE WARNINGS)
optimising.NVR <- optim(NVR.LSS.estimate, E,
freq = freq, empirical.spectrum = spec,
omega.j = omega.j.AP, structures = structures.AP,
sigma2 = sigma2, method = "Nelder-Mead")
# Final NVR estimate
NVR.nonlinear.estimate <- optimising.NVR$par
# Final sigma^2 estimate
final.sigma.est <- c(sigma2, sigma2 * NVR.nonlinear.estimate)
# Plotting AR(14) spectrum and DHR spectrum with estimated sigma,
# by using log loss function
plot(freq, log(spec), type = "l", col = "red", lwd = 2)
lines(freq, log(fullDHR.spectrum(freq,  final.sigma.est, omega.j.AP)),
lwd = 2, col = "green")
# Testing Step 4
# Elements defined in "Testing_Steps.R"
data.AP
T
sigma2
NVR.nonlinear.estimate
####### Preparing system, and observational matrixes #####
R <- 1 + 5 # Trend + Harmonic TVP's
n <- 2*R
omega.j <- c(0, 1/12, 1/6, 1/4, 1/3, 1/(2.4))
# Matrix H
H <- get.H(omega.j, T)
# Matrix F
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
F <- bdiag(c(list(F.IRW), replicate((R - 1), F.RW, simplify = FALSE)))
# Matrix G
G.IRW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
G <- bdiag(c(list(G.IRW), replicate((R - 1), G.RW, simplify = FALSE)))
# Matrix Q
Q <- diag(rep(sigma2 * NVR.nonlinear.estimate, 1, each = 2))
#### Filtering:
filtered.process <- Kalman.Filter(y = data.AP, F = F, H = H, G = G,
Q = Q, sigma2 = sigma2)
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
# Fitted values
fitted <- fitted.DHR(H, states)
# Plotting true and fitted value (after Filtering)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
smoothed.filtered.process <- Backward.Smoothing(filtered.process)
require(matrixcalc)
require(MASS)
smoothed.filtered.process <- Backward.Smoothing(filtered.process)
# Backward Smoothing Function
Backward.Smoothing <- function(filtered.process) {
if(!(class(filtered.process) == "Kalman.Filter")) {
stop("object \'filtered.process\' has to be of class \'Kalman.Filter\'")
}
# Required elements for backward smoothing, given by Kalman.Filter
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
prediction.P <- filtered.process$prediction.P
y <- filtered.process$y
F <- as.matrix(filtered.process$F)
H <- filtered.process$H
G <- filtered.process$G
Q.r <- (filtered.process$Q)/(filtered.process$sigma2)
T <- length(y)
n <- dim(Q.r)[1]
# New elements for backward smoothing
L <- list()
smoothed.states <- list()
smoothed.covariance.states <- list()
# Initial Step
smoothed.states[[T]] <- states[[T]]
L[[T]] <- as.matrix(rep(0, n), ncol = 1)
smoothed.covariance.states[[T]] <- covariance.states[[T]]
# F could be singular, in that case we use the generalised inverse
if(is.singular.matrix(F)) {
F.inv <- ginv(F, tol = sqrt(.Machine$double.eps))
}
else {
F.inv <- solve(F)
}
### Backward Pass Smoothing Equations:
for(t in (T-1):1) {
# Lagrange Multiplier
L[[t]] <- t((diag(n) - covariance.states[[t + 1]] %*%
t(H[[t + 1]]) %*%  H[[t + 1]])) %*%
( t(F) %*% L[[t + 1]] - t(H[[t + 1]]) %*%
(y[t + 1] - H[[t + 1]] %*% states[[t + 1]]))
# Smoothed States
smoothed.states[[t]] <- F.inv %*% (smoothed.states[[t + 1]] +
G %*% Q.r %*% t(G) %*% L[[t]])
# Smoothed Covariance States
A <- solve(prediction.P[[t + 1]],
smoothed.covariance.states[[t + 1]] - prediction.P[[t + 1]])
smoothed.covariance.states[[t]] <- covariance.states[[t]] +
covariance.states[[t]] %*% t(F) %*% A %*%
solve(prediction.P[[t + 1]], F %*% covariance.states[[t]])
}
return(list(smoothed.states = smoothed.states,
smoothed.covariance.states = smoothed.covariance.states))
}
smoothed.filtered.process <- Backward.Smoothing(filtered.process)
smoothed.states <- smoothed.filtered.process$smoothed.states
smoothed.fitted <- fitted(H, smoothed.states)
line(1:t, smoothed.fitted, type = "o", col = "green", pch = 20)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col =" red", pch = 20)
line(1:t, smoothed.fitted, type = "o", col = "green", pch = 20)
line(1:t, smoothed.fitted, type = "o")
line(1:t, smoothed.fitted)
lines(1:t, smoothed.fitted, type = "o", col = "green", pch = 20)
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
F <- bdiag(c(list(F.IRW), replicate((R - 1), F.RW, simplify = FALSE)))
# Matrix G
G.IRW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
G <- bdiag(c(list(G.IRW), replicate((R - 1), G.RW, simplify = FALSE)))
# Matrix Q
Q <- diag(rep(sigma2 * NVR.nonlinear.estimate, 1, each = 2))
#### Filtering:
filtered.process <- Kalman.Filter(y = data.AP, F = F, H = H, G = G,
Q = Q, sigma2 = sigma2)
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
# Fitted values
fitted <- fitted.DHR(H, states)
# Plotting true and fitted value (after Filtering)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
F.IRW <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)
F.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
F <- bdiag(c(list(F.IRW), replicate((R - 1), F.RW, simplify = FALSE)))
# Matrix G
G.IRW <- matrix(c(0, 0, 0, 1), nrow = 2, ncol = 2)
G.RW <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
G <- bdiag(c(list(G.IRW), replicate((R - 1), G.RW, simplify = FALSE)))
# Matrix Q
Q <- diag(rep(sigma2 * NVR.nonlinear.estimate, 1, each = 2))
#### Filtering:
filtered.process <- Kalman.Filter(y = data.AP, F = F, H = H, G = G,
Q = Q, sigma2 = sigma2)
states <- filtered.process$states
covariance.states <- filtered.process$covariance.states
# Fitted values
fitted <- fitted.DHR(H, states)
# Plotting true and fitted value (after Filtering)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
lines(1:t, fitted + rnorm(t, 0, sd = sigma2), type = "o", col = "red", pch = 20)
plot(1:t, data.AP, type = "o")
lines(1:t, fitted + rnorm(t, 0, sd = sqrt(sigma2)), type = "o", col = "red", pch = 20)
H[[1]]
plot(1:t, data.AP, type = "o")
lines(1:t, fitted, type = "o", col = "red", pch = 20)
