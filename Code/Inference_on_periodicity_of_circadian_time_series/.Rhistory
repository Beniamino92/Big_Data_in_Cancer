(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
bootstrap.spectrum
c <- 10^(-2)
initial.bandwith <- c * (n ^ (-1/4)); initial.bandwith
middle.bandiwth <- c *(n ^ (-1/6)); middle.bandiwth
final.bandwith <- c * (n ^ (-1/5)); final.bandwith
# Ok now let's try to make it
R <- 1000
bootstrap.spectrum <- matrix(NA, ncol = R, nrow  = n.tilda)
for(r in 1:R) {
# Step 1
residuals <- I[1:n.tilda]/
smoothed.periodogram(freq.rad, I, b = initial.bandwith)
residuals.scaled <- residuals/(sum(residuals)/n.tilda)
# Step 2
bootstrap.residuals <- sample(residuals.scaled, size = n.tilda)
bootstrap.periodogram <-
smoothed.periodogram(freq.rad, I, b = middle.bandiwth) *
bootstrap.residuals
bootstrap.spectrum[, r] <- smoothed.periodogram(freq.rad,
bootstrap.periodogram,
b = final.bandwith)
}
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
c <- 0.15
initial.bandwith <- c * (n ^ (-1/4)); initial.bandwith
middle.bandiwth <- c *(n ^ (-1/6)); middle.bandiwth
final.bandwith <- c * (n ^ (-1/5)); final.bandwith
# Ok now let's try to make it
R <- 1000
bootstrap.spectrum <- matrix(NA, ncol = R, nrow  = n.tilda)
for(r in 1:R) {
# Step 1
residuals <- I[1:n.tilda]/
smoothed.periodogram(freq.rad, I, b = initial.bandwith)
residuals.scaled <- residuals/(sum(residuals)/n.tilda)
# Step 2
bootstrap.residuals <- sample(residuals.scaled, size = n.tilda)
bootstrap.periodogram <-
smoothed.periodogram(freq.rad, I, b = middle.bandiwth) *
bootstrap.residuals
bootstrap.spectrum[, r] <- smoothed.periodogram(freq.rad,
bootstrap.periodogram,
b = final.bandwith)
}
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, rowMeans(bootstrap.spectrum), type = "l")
plot(freq.rad, I[1:n.tilda], type = "l")
plot(freq.rad, rowMeans(bootstrap.spectrum), type = "l")
plot(freq.rad, rowMeans(bootstrap.spectrum), type = "l")
plot(freq.rad, rowMeans(bootstrap.spectrum), type = "l")
plot(freq.rad, I[1:n.tilda], type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, log(I[1:n.tilda]), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, log(I[1:n.tilda]), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
R <- 10000
bootstrap.spectrum <- matrix(NA, ncol = R, nrow  = n.tilda)
for(r in 1:R) {
# Step 1
residuals <- I[1:n.tilda]/
smoothed.periodogram(freq.rad, I, b = initial.bandwith)
residuals.scaled <- residuals/(sum(residuals)/n.tilda)
# Step 2
bootstrap.residuals <- sample(residuals.scaled, size = n.tilda)
bootstrap.periodogram <-
smoothed.periodogram(freq.rad, I, b = middle.bandiwth) *
bootstrap.residuals
bootstrap.spectrum[, r] <- smoothed.periodogram(freq.rad,
bootstrap.periodogram,
b = final.bandwith)
}
par(mfrow = c(2, 1))
plot(freq.rad, log(I[1:n.tilda]), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
c <- 0.04
initial.bandwith <- c * (n ^ (-1/4)); initial.bandwith
middle.bandiwth <- c *(n ^ (-1/6)); middle.bandiwth
final.bandwith <- c * (n ^ (-1/5)); final.bandwith
# Ok now let's try to make it
R <- 1000
bootstrap.spectrum <- matrix(NA, ncol = R, nrow  = n.tilda)
for(r in 1:R) {
# Step 1
residuals <- I[1:n.tilda]/
smoothed.periodogram(freq.rad, I, b = initial.bandwith)
residuals.scaled <- residuals/(sum(residuals)/n.tilda)
# Step 2
bootstrap.residuals <- sample(residuals.scaled, size = n.tilda)
bootstrap.periodogram <-
smoothed.periodogram(freq.rad, I, b = middle.bandiwth) *
bootstrap.residuals
bootstrap.spectrum[, r] <- smoothed.periodogram(freq.rad,
bootstrap.periodogram,
b = final.bandwith)
}
par(mfrow = c(1, 1))
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
plot(freq.rad, log(I[1:n.tilda]), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
par(mfrow = c(1, 1))
plot(freq.rad, log(I[1:n.tilda]), type = "l")
plot(freq.rad, log(rowMeans(bootstrap.spectrum)), type = "l")
# Smoothed periodogram
I.smooth <- smoothed.periodogram(freq.rad, I, b = 0.05)
# Plotting periodgram and smoothed periodogram
plot(freq, log(I[1:n.tilda]), type = "l")
lines(freq, log(I.smooth[1:n.tilda]), type = "l",
col = "red", lwd = 2)
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- (v1*k1)/((k1 + P)^hc) - (v2*M)/(k2 + M)
return(out)
}
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- (v1*k1)/((k1 + P)^hc) - (v2*M)/(k2 + M)
return(out)
}
####### Function:  Drift for protein
drift.P <- function(M, P, parameters.P) {
# Getting parameters
alpha <- parameters.P[1]
delta.P <- parameters.P[2]
# WARNING: We're using just M(t), not g(M(t))
g.M <- M
# Drift
out <- alpha * g.M - delta.P * P
return(out)
}
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- (v1*k1)/((k1 + P)^hc) - (v2*M)/(k2 + M)
return(out)
}
####### Function:  Drift for protein
drift.P <- function(M, P, parameters.P) {
# Getting parameters
alpha <- parameters.P[1]
delta.P <- parameters.P[2]
# WARNING: We're using just M(t), not g(M(t))
g.M <- M
# Drift
out <- alpha * g.M - delta.P * P
return(out)
}
##### Function: Solving the ODE, with Euler scheme.
Euler <- function(M.start, P.start, parameters.M,
parameters.P, h, T, start = 0) {
# NUmber of steps required
n.steps <- (T - start) / h
# Variables and initial conditions
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- start
# Euler method
for(n in 1:n.steps) {
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
return(list(M = M, P = P))
}
parameters.M <- c(1.5, 1.3, (0.2)^4, 0.2, 4)
parameters.P <- c(2, 0.5)
test <- Euler(M.start = 200, P.start = 0,
parameters.M, parameters.P,
h = 1e-1, T = 100)
test$M
test$P
test <- Euler(M.start = 2, P.start = 0,
parameters.M, parameters.P,
h = 1e-1, T = 10)
test$M
test$P
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- (v1*k1)/((k1 + P)^hc) - (v2*M)/(k2 + M)
return(out)
}
####### Function:  Drift for protein
drift.P <- function(M, P, parameters.P) {
# Getting parameters
alpha <- parameters.P[1]
delta.P <- parameters.P[2]
# WARNING: We're using just M(t), not g(M(t))
g.M <- M * dgamma(M, 8, 1)
# Drift
out <- alpha * g.M - delta.P * P
return(out)
}
##### Function: Solving the ODE, with Euler scheme.
Euler <- function(M.start, P.start, parameters.M,
parameters.P, h, T, start = 0) {
# NUmber of steps required
n.steps <- (T - start) / h
# Variables and initial conditions
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- start
# Euler method
for(n in 1:n.steps) {
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
return(list(M = M, P = P))
}
(1.5, 1.3, (0.2)^4, 0.2, 4)
parameters.M <- c(1.5, 1.3, (0.2)^4, 0.2, 4)
parameters.P <- c(2, 0.5)
test <- Euler(M.start = 2, P.start = 0,
parameters.M, parameters.P,
h = 1e-1, T = 10)
test$M
test$P
plot.ts(test$M)
plot.ts(test$P)
plot.ts(test$M)
plot.ts(test$P)
test <- Euler(M.start = 2, P.start = 0,
parameters.M, parameters.P,
h = 1e-1, T = 100)
plot.ts(test$M)
plot.ts(test$P)
plot.ts(test$M)
plot.ts(test$P)
plot.ts(test$P[10:100])
T <- 5
start <- 0
h <- 1/10
T <- 20
start <- 0
h <- 1/10
tau <- 4
M.start <- 100
P.start <- 0
M <- c()
P <- c()
n.steps <- (T - start)/h; n.steps
tau/n.steps
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
####### Function:  Drift for protein
drift.P <- function(M, P, parameters.P) {
# Getting parameters
alpha <- parameters.P[1]
delta.P <- parameters.P[2]
# WARNING: We're using just M(t), not g(M(t))
g.M <- M
# Drift
out <- alpha * g.M - delta.P * P
return(out)
}
############ Retry again:
T <- 20
start <- 0
h <- 1/10
tau <- 4
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
plot.ts(M)
plot.ts(P)
T <- 100
start <- 0
h <- 1/10
tau <- 20
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
M
plot.ts(M[-2])
plot.ts(M[-1])
plot.ts(P[-1])
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- ((v1*k1)/((k1 + P)^hc)) - ((v2*M)/(k2 + M))
return(out)
}
####### Function: Drift for mRNA molecules
drift.M <- function(M, P, parameters.M) {
# Getting parameters
v1 <- parameters.M[1]
v2 <- parameters.M[2]
k1 <- parameters.M[3]
k2 <- parameters.M[4]
hc <- parameters.M[5]
# Drift
out <- ((v1*k1)/((k1 + P)^hc)) - ((v2*M)/(k2 + M))
return(out)
}
####### Function:  Drift for protein
drift.P <- function(M, P, parameters.P) {
# Getting parameters
alpha <- parameters.P[1]
delta.P <- parameters.P[2]
# WARNING: We're using just M(t), not g(M(t))
# Drift
out <- (alpha * M) - (delta.P * P)
return(out)
}
############ Retry again:
T <- 100
start <- 0
h <- 1/10
tau <- 20
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
print(t)
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
############ Retry again:
T <- 100
start <- 0
h <- 1/10
tau <- 20
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
cat('t: ',t, '\n')
cat('n: ',b, '\n')
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
############ Retry again:
T <- 100
start <- 0
h <- 1/10
tau <- 20
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
cat('t: ',t, '\n')
cat('n: ',n, '\n')
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
T <- 10
start <- 0
h <- 1/10
tau <- 2
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
cat('t: ',t, '\n')
cat('n: ',n, '\n')
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
############ Retry again:
T <- 10
start <- 0
h <- 1/10
tau <- 2
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
cat('t: ',t, '\n')
cat('n: ',n, '\n')
cat('M[', (t - tau) + 1,'] \n')
cat('\n')
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
############ Retry again:
T <- 10
start <- 0
h <- 1/10
tau <- 2
n.steps <- (T - start)/h; n.steps
M.start <- 100
P.start <- 0
M <- c(); M[1] <- M.start
P <- c(); P[1] <- P.start
t <- 0
for(n in 1:n.steps) {
t <- t + h
M[n + 1] <- M[n] + h * drift.M(M[n], P[n], parameters.M)
if(t < tau) {
P[n + 1] <- P[n] + h * drift.P(M[n], P[n], parameters.P)
}
else{
cat('t: ',t, '\n')
cat('n: ',n, '\n')
cat('M[', (t - tau) + 1,'] = ', M[(t - tau) + 1])
cat('\n')
g.M <- M[(t - tau) + 1]
P[n + 1] <- P[n] + h * drift.P(g.M, P[n], parameters.P)
}
}
