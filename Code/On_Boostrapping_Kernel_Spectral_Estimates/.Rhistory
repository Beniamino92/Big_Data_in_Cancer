k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19))
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
test <- Spectral.Resampling.CI(SR.sample, plot = TRUE)
test <- Spectral.Resampling.CI(SR.sample)
test$p
test <- Spectral.Resampling.CI(SR.sample)
test$p
SR.sample <- Spectral.Resampling(data = x, c = c, R = 100)
# Getting average, and confindence intervals for the spectrum
SR <- Spectral.Resampling.CI(SR.sample)
# Plotting results
test$plot
SR$plot
### Function: Get Average, and Confindence Intervals of SR
###           and an optional plot.
Spectral.Resampling.CI <- function(SR.sample, plot = FALSE) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
if(plot == TRUE) {
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19))
p
}
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
SR <- Spectral.Resampling.CI(SR.sample)
SR <- Spectral.Resampling.CI(SR.sample, plot = TRUE)
SR$plot
Spectral.Resampling.CI <- function(SR.sample, plot = FALSE) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
if(plot == TRUE) {
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black", linetype = "dashed") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19))
}
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
SR <- Spectral.Resampling.CI(SR.sample, plot = TRUE)
# Plotting results
SR$plot
Spectral.Resampling.CI <- function(SR.sample, plot = FALSE) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
if(plot == TRUE) {
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black", linetype = "dashed") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black", linetype = "dashed") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19))
}
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
SR <- Spectral.Resampling.CI(SR.sample, plot = TRUE)
# Plotting results
SR$plot
getwd()
SR$mean
SR$spec
spectrum <- SR$spec
install.packages("pracma")
library("pracma")
findpeaks(spectrum)
?findpeaks
peaks <- findpeaks(spectrum)
peaks[1, 2]
freq.rad[peaks[1, 2]]
freq.rad[peaks[2, 2]]
freq.rad[peaks[3, 2]]
### Function: Get Average, and Confindence Intervals of SR
###           and an optional plot.
Spectral.Resampling.CI <- function(SR.sample) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black", linetype = "dashed") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black", linetype = "dashed") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.5))
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
### Function: Get Average, and Confindence Intervals of SR
###           and an optional plot.
Spectral.Resampling.CI <- function(SR.sample) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black", linetype = "dashed") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black", linetype = "dashed") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.1))
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
SR <- Spectral.Resampling.CI(SR.sample, plot = TRUE)
SR <- Spectral.Resampling.CI(SR.sample)
# Plotting results
SR$plot
peaks <- findpeaks(spectrum)
freq.rad[peaks[1, 2]]
freq.rad[peaks[2, 2]]
freq.rad[peaks[3, 2]]
counts <- c()
dim(SR.sample)
counts <- c()
for(r in 1:100) {
counts[r] <- freq.rad[findpeaks(SR.sample[, r])[1, 2]]
}
hist(counts)
counts
hist(counts, xlim = c(0, pi))
hist(counts, xlim = c(0, pi), breaks = 10)
hist(counts, xlim = c(0, pi), breaks = 1)
hist(counts, xlim = c(0, pi), breaks = 2)
hist(counts, xlim = c(0, pi), breaks = 3)
hist(counts, xlim = c(0, pi), breaks = 4)
hist(counts, xlim = c(0, pi), breaks = 5)
hist(counts, xlim = c(0, pi), breaks = 5, col = "pink")
counts1 <- c()
counts2 <- c()
counts3 <- c()
counts1 <- c()
counts2 <- c()
counts3 <- c()
for(r in 1:100) {
counts1[r] <- freq.rad[findpeaks(SR.sample[, r])[1, 2]]
counts2[r] <- freq.rad[findpeaks(SR.sample[, r])[2, 2]]
counts3[r] <- freq.rad[findpeaks(SR.sample[, r])[3, 2]]
}
counts <- c(counts1, counts2, counts3)
hist(counts, xlim = c(0, pi), breaks = 5, col = "pink")
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink")
hist(counts, xlim = c(0, pi), breaks = 30, col = "pink")
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink")
par(mfrow = c(2, 1))
plot(freq.rad, SR$spec, col = "red", lwd = 2)
plot(freq.rad, SR$spec, col = "red", lwd = 2, type = "l")
plot(freq.rad, SR$spec, col = "red", lwd = 2, type = "l", xlim = c(0, pi))
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink")
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink", main = "")
plot(freq.rad, SR$spec, col = "red", lwd = 2, type = "l", xlim = c(0, pi))
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink", main = "")
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink", main = "")
plot(freq.rad, SR$spec, col = "red", lwd = 2, type = "l", xlim = c(0, pi))
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink", main = "")
dat <- data.frame(counts)
ggplot(data = dat)
ggplot(data = dat, aes(dat$counts))
ggplot(data = dat, aes(dat$counts)) + geom_histogram(fill = "green")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "green", col = "red")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "red")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "grey", col = "red")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "blue", col = "red")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black") +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = 5) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = 2)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = 0.1)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .05)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .06)) +
coord_cartesian(xlim = c(0, pi))
par(mfrow = c(2, 1))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .06)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .07)) +
coord_cartesian(xlim = c(0, pi)) +
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi))
plot(freq.rad, SR$spec, col = "red", lwd = 2, type = "l", xlim = c(0, pi))
hist(counts, xlim = c(0, pi), breaks = 20, col = "pink", main = "")
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "pink", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "blue", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi))
ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "blue", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.1))
ciao <- ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "blue", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.1))
hello <- SR$plot
multiplot(hello, ciao)
library(grid)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(hello, ciao)
ciao <- list()
R <- 10
ciao <- list()
R <- 10
for(n in 1:3) {
for(r in 1:R) {
ciao[[n]][r] <- 1
}
}
ciao <- list()
ciao <- list()
for(n in 1:3) {
ciao[[n]] <- c()
}
for(n in 1:3) {
for(r in 1:R) {
ciao[[n]][r] <- 1
}
}
ciao <- ggplot(data = dat, aes(dat$counts)) +
geom_histogram(fill = "blue", col = "black", breaks = seq(0, pi, by = .04)) +
coord_cartesian(xlim = c(0, pi)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.1)) +
theme(plot.margin = unit(c(1,1,1,1), "cm"))
multiplot(hello, ciao)
Spectral.Resampling.CI <- function(SR.sample) {
# Getting dimensions and setting frequencies
n.tilda <- nrow(SR.sample)
n <- n.tilda*2
k <- 0:(n.tilda - 1)
freq.rad <- (2*pi*k)/ n
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# Creating confidence intervals for spectrum estimate
conf.int <- matrix(NA, nrow = n.tilda, ncol = 2)
for(i in 1:n.tilda) {
conf.int[i, ] <- quantile(SR.sample[i, ], probs = c(.05, .95))
}
# Average
mean.spectrum.SR <- rowMeans(SR.sample)
# Auxiliary data.frame for plotting
dat <- data.frame(freq = freq.rad, spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1])
# Plotting mean and C.I
p <- ggplot() +
geom_line(data = dat,
aes(x = freq.rad, y = spec, linetype = "c"),
size = 1.0, colour = "red") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.up),
size = 0.6, colour = "black", linetype = "dashed") +
geom_line(data = dat,
aes(x = freq.rad, y = ci.low),
size = 0.6, colour = "black", linetype = "dashed") +
xlab("Frequency") + ylab("Power Spectrum") +
ggtitle("Spectral Resampling (SR)") +
theme(legend.position = "none",
plot.title = element_text(size = 19)) +
scale_x_continuous(minor_breaks = seq(0, pi, 0.1)) +
theme(plot.margin = unit(c(1,1,1,1), "cm"))
return(list(spec = mean.spectrum.SR,
ci.up = conf.int[, 2], ci.low = conf.int[, 1],
plot = p))
}
SR <- Spectral.Resampling.CI(SR.sample)
# Plotting results
hello <- SR$plot
multiplot(hello, ciao)
SR.distribution <- function(SR.sample, n.peaks, period = FALSE) {
# Checking input
if(class(SR.sample) != "SR")
stop("input not of class SR")
# This library implement the function findpeaks
library(pracma)
# Setting dimensions and frequency parameters
R <- dim(SR.sample)[2]
n.tilda <- dim(SR.sample)[1]
n <- n.tilda * 2
k <- 0:(n.tilda - 1)
freq.rad <- 2*pi*k/n
freq <- k/n
# Largest peaks in each bootstrap sample
counts <- matrix(NA, nrow = R, ncol = n.peaks)
# Getting largest peaks for each bootstrap sample
for(n in 1:n.peaks) {
for(r in 1:R) {
if(period == TRUE) {
counts[n, r] <- 1/(freq[findpeaks(SR.sample[, r])[n, 2]])
}
else {
counts[n, r] <- freq.rad[findpeaks(SR.sample[, r])[n, 2]]
}
}
}
return(counts)
}
SR.distribution(SR.sample, n.peaks = 3, period = FALSE)
SR.distribution(SR.sample, n.peaks = 3, period = FALSE)
